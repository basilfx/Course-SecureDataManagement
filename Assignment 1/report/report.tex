\documentclass[a4paper]{article}

\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{parskip}
\usepackage{float}
\usepackage{hyperref}
\usepackage{fullpage}
\usepackage{listings}
\usepackage[T1]{fontenc}

\lstset{
	numberstyle=\footnotesize,
	basicstyle=\footnotesize\ttfamily,
	breaklines=true
}

\begin{document}

\title{Assignment 1 \\ Secure Data Management}
\author{Rick van Galen - s0167746 (UT) \\ Erwin Middelesch - s0197106 (UT) \\ Jeroen Senden - s0191213 (UT) \\ Bas Stottelaar - s0199141 (UT)}
\date{\today}
\maketitle

\section{Introduction}
	In this report, we describe our implementation for a Public Health Record (PHR) system. This system is implemented in Python and consists of a client and server. The role of the server is to announce the public parameters and store encrypted data while the client takes care of the encryption and decryption of data.

	Our solution is based on a Ciphertext-Policy Attribute-Based Encryption (CP-ABE) scheme and uses no classic access control to authenticate users. Different categories of data can be read and written by different parties or sub parties.
	
	First, we introduce the data model, including the categories of data and different parties. Then, we introduce the access policies. The third section will discuss the actual implementation and verifies the the requirements. The last section will discuss our implementation.

\section{Data model}

	\subsection{Data categories}
		The system defines the categories below. 
		
		\begin{description}
		    \item[Patient data]
		    In this segment of the health record, we store personal information of the user. 
		    \item[Health data]
		    This is the data inserted by a hospital where the user has been treated.
		    \item[Training data]
		    This section contains training related data stored by the health club.
		\end{description}
		
	\subsection{Parties}
		The following parties are defined and assumed to work with the system.
		
		\begin{description}
			\item[Patient] The subject of the electronic health system. Each health record is associated with one patient and should be under full control of the patient. The patient has full read and write access to every category of data.
			\item[Doctor] A patient's doctor treats the patient with health issues. The doctor may require read access to any part of a patient's health record. Therefore, the patient may choose to give the doctor read access to his personal information, health data and training data.
			\item[Insurance] Health insurance companies may want to read a patient's records for fee calculations or health verification. A patient may give insurance companies read access to all of the segments of the his/her health record.
			\item[Employer] Like the insurance company, an employer may need access to an employee's health information and may be granted read access.  
			\item[Hospital] Hospitals are given read and write access to the health data of the health record. An additional restriction is that a hospital may only write to the health record when a patient has been treated at that hospital.
			\item[Health club] The health club provides the user with additional health services and training programs. Because this information is relevant to the health record, the health club gets read and write access to the training related segment of a patients health record.
		\end{description}

\section{Access model}
	\subsection{Policies}
	
	\subsection{Phases}
		\subsubsection{Setup}
	
		\subsubsection{Keygen}
		
		\subsubsection{Encrypt}
		
		\subsubsection{Decrypt}
    
\section{Implementation}
	This section describes the practical implementation of the assignment.
	
	\subsection{Architecture}
		Client/Server
	
		Django + Charm
		
		AES
		
		All relevant parts\footnote{All code not related to the Django framework.} of the code is documented and tested. We refer to the source code for an in-depth overview.
	
	\subsection{Database model}
		The role of the database is minimal. This also resulted in a very small database model.
		
		\begin{description}
			\item[Record table]
			\textit{ID, Record name} 
			\item[Record item table]
			\textit{ID, Record ID, Category, Data} 			
			\item[Keystore table]
			\textit{ID, Record ID, Category, Data}
		\end{description}
	
		Data is saved in Base64 encoded string, representing the cipher text.
	
	\subsection{Verification of requirements}
		The assignment includes the following requirements:
		
		\begin{enumerate}
			\item{A patient can insert personal health data into his \textit{own} record.}
			\item{A patient can provide his doctor, his insurance, and his employer with read access to (parts of) his health record.}
			\item{A hospital can insert patient health data for any patient that has been treated by \textit{that} hospital.}
			\item{A health club can insert training-related health data to any patient record that is a member of \textit{that} club.}
		\end{enumerate}
		
		To show that our system fulfills the requirements, we show a few use cases operated via the command line interface. One can play all use cases and should see similar results.
		
		\subsubsection{Creating a PHR}\label{sec:usecase_1}
			Since the patient is in control of his own PHR, he is responsible for creating one.
		
			\begin{lstlisting}
>>> python manage.py phr_create patient.json http://127.0.0.1:8000 "Patient record"
BEGIN SECRET READ FOR KEYS DOCTOR
(...truncated for clearance...)
END SECRET READ KEYS FOR DOCTOR

BEGIN SECRET READ FOR KEYS HOSPITAL-A
(...truncated for clearance...)
END SECRET READ KEYS FOR HOSPITAL-A

...

BEGIN SECRET READ FOR KEYS EMPLOYER
(...truncated for clearance...)
END SECRET READ KEYS FOR EMPLOYER

BEGIN SECRET READ FOR KEYS INSURANCE
(...truncated for clearance...)
END SECRET READ KEYS FOR INSURANCE
			\end{lstlisting}
		
			After running this command, all the secret reading keys for all the parties are generated. Each key has a bit of meta data encoded to connect to the right PHR. The mapping (see section XXX) defines who will get initial read access to which category of data. The patient should take care of distributing the keys, preferably via an out-of-band channel.
		
			A patient can encrypt data for other parties even if the keys have not yet been distributed.
		
		\subsubsection{Writing data}\label{sec:usecase_2}
			The patient decides to encrypt two messages. The first message can be read by his doctor, the second one by his insurance and his employer. They have access to the personal category of data.
		
			\begin{lstlisting}
>>> python manage.py phr_encrypt patient.json PERSONAL DOCTOR "Hi, Doctor!"
Uploaded to record item ID 55
>>> python manage.py phr_encrypt patient.json PERSONAL INSURANCE,EMPLOYER "Hi, Insurance and Employer!"
Uploaded to record item ID 56
			\end{lstlisting}
		
			The identifiers correspond to the items in the PHR of the patient. To verify that the patient has read access, he will decrypt the data he sent to the server.
		
			\begin{lstlisting}
>>> python manage.py phr_decrypt patient.json 55
Record item content:

Hi, Doctor
>>> python manage.py phr_decrypt patient.json 56
Record item content:

Hi, Insurance and Employer
			\end{lstlisting}
		
		\subsubsection{Granting write access}\label{sec:usecase_3}
			By default, no other party has write access. The patient should grant write access for all parties or sub parties.
		
			Let's assume the patient wants to grant Hospital-A write access.
			
			\begin{lstlisting}		
>>> python manage.py phr_grant patient.json HEALTH HOSPITAL-A
Granted key for category HEALTH with key ID 22
			\end{lstlisting}
			
			The write key is encrypted for party Hospital-A. If the patient wanted, he could give all hospitals write access by specifying the Hospital party instead of Hospital-A.
		
		\subsubsection{Connecting to a PHR}\label{sec:usecase_4}
			In this step, the keys have been safely distributed to each party. We let each party connect to the PHR of the client.
		
			\begin{lstlisting}
>>> python manage.py phr_connect doctor.json http://127.0.0.1:8000
Paste the keys data, excluding the BEGIN and END block: (...paste key for doctor...)
Connected to record ID 28

...

>>> python manage.py phr_connect insurance.json http://127.0.0.1:8000
Paste the keys data, excluding the BEGIN and END block: (...paste key insurance...)
Connected to record ID 28
			\end{lstlisting}
			
		\subsubsection{Reading data}\label{sec:usecase_5}
			In the first step, we encrypted two messages. One for only the doctor (\#55), and one for both the insurance and employer (\#56). 
			
			First the doctor:
			
			\begin{lstlisting}
>>> python manage.py phr_decrypt doctor.json 55
Record item content:

Hi, Doctor
>>> python manage.py phr_decrypt doctor.json 56
Cannot decrypt record item
			\end{lstlisting}

			Then the employer and insurance:

			\begin{lstlisting}
>>> python manage.py phr_decrypt employer.json 56
Record item content:

Hi, Insurance and Employer
>>> python manage.py phr_decrypt insurance.json 56
Record item content:

Hi, Insurance and Employer
>>> python manage.py phr_decrypt employer.json 55
Cannot decrypt record item
>>> python manage.py phr_decrypt insurance.json 55
Cannot decrypt record item
			\end{lstlisting}
			
			And to be sure, we verify the health club and hospital cannot read the messages (they have read access to different categories).

			\begin{lstlisting}
>>> python manage.py phr_decrypt healthclub-a.json 55
Cannot decrypt record item
>>> python manage.py phr_decrypt healthclub-a.json 56
Cannot decrypt record item
>>> python manage.py phr_decrypt hospital-a.json 55
Cannot decrypt record item
>>> python manage.py phr_decrypt hospital-a.json 56
Cannot decrypt record item
			\end{lstlisting}
		
		\subsubsection{Retrieving write access}\label{sec:usecase_6}
			In step XXX we provided Hospital-A with a write key. The party should retrieve the key from the server.
			
			\begin{lstlisting}
>>> python manage.py phr_retrieve hospital-a.json HEALTH
Key(s) imported for HEALTH.
			\end{lstlisting}
			
			The same does not work for other parties, e.g. Hospital-B and Health Club-A:
		
			\begin{lstlisting}
>>> python manage.py phr_retrieve hospital-b.json HEALTH
No new key(s) imported.
>>> python manage.py phr_retrieve healtclub-a.json HEALTH
No new key(s) imported.
			\end{lstlisting}
		
			Just to verify the keys are imported, one can issue the status command.
			
			\begin{lstlisting}
>>> python manage.py phr_status hospital-a.json
Host:        http://127.0.0.1:8000
Categories:  PERSONAL, HEALTH, TRAINING
Parties:     DOCTOR, INSURANCE, EMPLOYER, HOSPITAL+A+B+C, HEALTHCLUB+A+B+C
Mappings:    PERSONAL -> DOCTOR, INSURANCE, EMPLOYER
             TRAINING -> HEALTHCLUB
             HEALTH -> HOSPITAL

Record ID:   28
Record name: Patient record
Record role: HOSPITAL-A

Master keys: <not set>
Public keys: HEALTH
Secret keys: HOSPITAL-A -> HEALTH
			\end{lstlisting}
			
			For the above case, Hospital-A has connected to the right record, is able to decrypt messages for Hospital-A in the Health category and can encrypt messages for the Health category. Note that the master keys are not available, so Hospital-A cannot generate new keys (only the patient can do this).
		
		\subsubsection{Writing a reply}\label{sec:usecase_7}
			Now Hospital-A has write access, he can write data to the Health category. To verify this, we will write a message to the Health category only for the patient and one to all hospitals.
			
			\begin{lstlisting}
>>> python manage.py phr_encrypt hospital-a.json HEALTH HOSPITAL "Hello patient!""
Uploaded to record item ID 57
>>> python manage.py phr_encrypt hospital-a.json HEALTH HOSPITAL "Hello patient and other hospitals!""
Uploaded to record item ID 58
			\end{lstlisting}
			
			To conclude, each addressed party will decode it:

			\begin{lstlisting}
>>> python manage.py phr_decrypt hospital-a.json 57
Record item content:

Hello patient!
>>> python manage.py phr_decrypt hospital-b.json 57
Cannot decrypt record item
>>> python manage.py phr_decrypt hospital-c.json 57
Cannot decrypt record item
>>> python manage.py phr_decrypt hospital-a.json 58
Record item content:

Hello patient and other hospitals!
>>> python manage.py phr_decrypt hospital-b.json 58
Record item content:

Hello patient and other hospitals!

>>> python manage.py phr_decrypt hospital-c.json 58
Record item content:

Hello patient and other hospitals!
			\end{lstlisting}

			And the patient:

			\begin{lstlisting}
>>> python manage.py phr_decrypt patient.json 57
Record item content:

Hello patient!
>>> python manage.py phr_decrypt patient.json 58
Record item content:

Hello patient and other hospitals!
			\end{lstlisting}
		
		\subsubsection{A second patient record}\label{sec:usecase_8}
			A patient is in control of his own PHR and has all the keys to read and write. In this use case, we show that a other patient cannot decrypt a record item that does not belong to him. Because the API to communicate with the server requires the user to specify a record item ID and the record ID, we modified it for this test to only require the record item ID. If we did not do this, the users would not be able to use the command line to request for a record item from a different record.
			
			First, we create a second patient.
			
			\begin{lstlisting}
>>> python manage.py phr_create patient.json http://127.0.0.1:8000 "Patient two record"
BEGIN SECRET READ FOR KEYS DOCTOR
(...truncated for clearance...)
END SECRET READ KEYS FOR DOCTOR

BEGIN SECRET READ FOR KEYS HOSPITAL-A
(...truncated for clearance...)
END SECRET READ KEYS FOR HOSPITAL-A

...

BEGIN SECRET READ FOR KEYS EMPLOYER
(...truncated for clearance...)
END SECRET READ KEYS FOR EMPLOYER

BEGIN SECRET READ FOR KEYS INSURANCE
(...truncated for clearance...)
END SECRET READ KEYS FOR INSURANCE
			\end{lstlisting}
			
			Then, we connect the (same) doctor to that record, since patient one encrypted a message (\#55) for him.
			
			\begin{lstlisting}
>>> python manage.py phr_connect doctor-patient-two.json http://127.0.0.1:8000
Paste the keys data, excluding the BEGIN and END block: (...paste key for doctor...)
Connected to record ID 29
			\end{lstlisting}
			
			It should be sufficient to show that both the patient two and the doctor with the other data file cannot read message from patient one.
			
			\begin{lstlisting}
>>> python manage.py phr_decrypt patient-two.json 55
Cannot decrypt record item
>>> python manage.py phr_decrypt doctor-patient-two.json 55
Cannot decrypt record item
			\end{lstlisting}
		
		\subsubsection{Conclusion}
			We conclude this section with a table representing which requirement is fulfilled by which use case.

			\begin{table}[h!]
			    \begin{tabular}{| l | l | l | l | l |} \hline
			    ~                            & Requirement 1 & Requirement 2 & Requirement 3 & Requirement 4 \\ \hline
			    Use case \ref{sec:usecase_1} & ~             & X             & ~             & ~             \\ \hline
			    Use case \ref{sec:usecase_2} & X             & ~             & ~             & ~             \\ \hline
			    Use case \ref{sec:usecase_3} & ~             & ~             & X             & X             \\ \hline
			    Use case \ref{sec:usecase_4} & ~             & X             & ~             & ~             \\ \hline
			    Use case \ref{sec:usecase_5} & ~             & X             & ~             & ~             \\ \hline
			    Use case \ref{sec:usecase_6} & ~             & ~             & X             & X             \\ \hline
			    Use case \ref{sec:usecase_7} & ~             & ~             & X             & X             \\ \hline
			    Use case \ref{sec:usecase_8} & X             & ~             & ~             & ~             \\ \hline
			    \end{tabular}
			\end{table}
	
\section{Discussion}

	\subsection{Authentication}
		Our implementation does not authenticate a party to the server and visa versa. This does not have any impact on the secrecy of the data, since only the once with the right keys, distributed via secure channels, can read or write data. The server cannot learn anything from the data. However, since anyone can upload data to our server, a lot of false and corrupt data may be stored in the database. A client cannot delete data, since the server does not know the client.
		
		Since this is out of the scope of this assignment, we have not implemented a counter measure.
		
	\subsection{Number of keys}
		There are a lot of keys to be generated during the setup and keygen phase. There are $N$ master keys and $N$ public keys for $N$ categories. Based on the mapping, each party having read access gets at least one read key. If the number of parties (and sub parties) grow, the number of read keys grows too.
		
		Only the patient has to store all the keys. All other parties should only store their read and write keys.
	
	\subsection{Key sharing}
		For each category of data, there is only one master key and one write key. The write key is shared among the parties if they want write access. If a party is malicious, he could impersonate another party or spread the write key. 
		
		In the given assignment this is not a problem, since only write access is granted to the hospital and health club, both operating on a different category of data. It would be very easy to trace it back to a malicious party.

\section{References}
	\bibliography{references}
	\bibliographystyle{plain}

\end{document}